# # Elastic deformation
#
# Authors: Jack. S. Hale and JÃ¸rgen S. Dokken
#
# In this example, we will show how to use FEniCS to solve the equations of linear elasticity and hyper-elasticity with FEniCS.
# We start by importing the required modules.

# +
from mpi4py import MPI
import ufl
import dolfinx.fem.petsc
import basix.ufl
# -

# # Loading meshes
# DOLFINx has a wide range of ways of loading meshes. One of the most common formats is the `.msh` format, which we provide wrappers for

mesh_data = dolfinx.io.gmsh.read_from_msh("mesh.msh", comm=MPI.COMM_WORLD, rank=0)
domain = mesh_data.mesh
cell_tags = mesh_data.cell_tags
facet_tags = mesh_data.facet_tags

# We can for instance inspect the geometry with pyvista

import pyvista

grid = pyvista.UnstructuredGrid(*dolfinx.plot.vtk_mesh(domain))
plotter = pyvista.Plotter(shape=(1, 2))
plotter.subplot(0, 0)
plotter.add_mesh(grid, show_edges=True)

# Additionally we add the facet markers

markers = pyvista.UnstructuredGrid(
    *dolfinx.plot.vtk_mesh(domain, domain.topology.dim - 1, facet_tags.indices)
)
markers.cell_data["markers"] = facet_tags.values
plotter.subplot(0, 1)
plotter.add_mesh(grid, style="wireframe")
plotter.add_mesh(markers)
plotter.link_views()
plotter.show()

# We can store the mesh to XDMF to visualize it in Paraview

with dolfinx.io.XDMFFile(domain.comm, "mesh.xdmf", "w") as xdmf:
    xdmf.write_mesh(domain)
    xdmf.write_meshtags(facet_tags, domain.geometry)

# ![Example tool from CAD generated by Joe Dean (University of Cambridge)](./example_tool.png)

# # Finite elements and function spaces

# Next, we pick a finite element function space to use for the unknown displacement $\mathbf{u}$
# The grid we have loaded can be arbitrary order Lagrangian (i.e. can have curved edges).
# We do not need to take this into account when choosing the function space, as FEniCS supports
#
# - subparameteric
# - isoparametric
# - superparameteric
#
# discretizations.

degree_displacement = 3
el = basix.ufl.element(
    "Lagrange", domain.basix_cell(), degree_displacement, shape=(domain.geometry.dim,)
)
V = dolfinx.fem.functionspace(domain, el)

# # The energy functional

# One of the ways of deriving the equations of elasticity is by minimizing the potential energy of the structure.

# For linear elasticity, that would be
#
# $$ \min_\mathbf{u\in V_g} J(\mathbf{u}) = \frac{1}{2} \int_\Omega \sigma(\mathbf{u}): \epsilon (\mathbf{u})~\mathrm{d}x - \int_\Omega \mathbf{f}\cdot \mathbf{u}~\mathrm{d}x - \int_{\partial\Omega_N}\mathbf{t}\cdot u~\mathrm{d}s$$
#
# where $\sigma(\mathbf{u})=2\mu \epsilon(\mathbf{u})$ is the stress, $\epsilon(\mathtbf{u}})= \frac{1}{2}(\nabla \mathbf{u}+(\nabla \mathbf{u})^T) is the infinitesimal strain.
# $\mathbf{g}$ describes the surface displacement at $\partial\Omega_D$
#
#

E = dolfinx.fem.Constant(domain, dolfinx.default_scalar_type(1.0e4))
nu = dolfinx.fem.Constant(domain, dolfinx.default_scalar_type(0.3))
mu = E / (2 * (1 + nu))
lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))


uh = dolfinx.fem.Function(V)
I = ufl.Identity(len(uh))
F = I + ufl.grad(uh)
C = F.T * F
E = ufl.variable(0.5 * (C - I))
W = lmbda / 2 * (ufl.tr(E) ** 2 + mu * ufl.tr(E * E))

v = ufl.TestFunction(V)
x = ufl.SpatialCoordinate(domain)
t = ufl.as_vector((0, 0, -(x[0] + x[1])))

J = W * ufl.dx
residual = ufl.derivative(J, uh, v)


S = ufl.diff(W, E)  # Second order Piola-Kirchhoff stress tensor
P = F * S
residual_alt = ufl.inner(P, ufl.grad(v)) * ufl.dx


g = dolfinx.fem.Function(V)
g.x.array[:] = 0.0
fixed_dofs = dolfinx.fem.locate_dofs_topological(V, facet_tags.dim, facet_tags.find(58))
bcs = [dolfinx.fem.dirichletbc(g, fixed_dofs)]


petsc_opts = {
    "snes_type": "newtonls",
    "ksp_type": "preonly",
    "pc_type": "lu",
    "pc_factor_mat_solver_type": "mumps",
    "snes_monitor": None,
    "snes_error_if_not_converged": True,
}

f = dolfinx.fem.Constant(domain, (0.0, 0.0, -9.81))
ds = ufl.Measure("ds", domain=domain, subdomain_data=facet_tags)
dsN = ds(59)
forces = ufl.inner(f, v) * ufl.dx + ufl.inner(t, v) * dsN
Fhat = residual - forces
problem = dolfinx.fem.petsc.NonlinearProblem(
    Fhat, uh, bcs=bcs, petsc_options_prefix="t1", petsc_options=petsc_opts
)

problem.solve()

with dolfinx.io.VTXWriter(domain.comm, "sol1_svk.bp", [uh]) as bp:
    bp.write(0.0)

uh.x.array[:] = 0.0
Fhat = residual_alt - forces
problem2 = dolfinx.fem.petsc.NonlinearProblem(
    Fhat, uh, bcs=bcs, petsc_options_prefix="t1", petsc_options=petsc_opts
)

problem.solve()

with dolfinx.io.VTXWriter(domain.comm, "sol2_svk.bp", [uh]) as bp:
    bp.write(0.0)
